#include "vxWorks.h"
#include "taskLib.h"
#include "stdlib.h"
#include "stdio.h"
#include "cinterface.h"
#include "wdLib.h"
#include "time.h"

/* Counter for all blocks detected by size sensor 1 */
int blocksDetected = 0;

/* Counter for small blocks */
int smallBlocksDetected = 0;

/* Counter for big blocks */
int bigBlocksDetected = 0;



/* ID for semaphore that controls sensor reads */
SEM_ID sensor_read_sem_id;

/* ID for watchdog timer to reschedule sensor reads task */
WDOG_ID sensor_read_timer_ID;

/* ID of periodic task to read sensors */
int sensor_read_task_id;

/* ID of periodic task to print state */
int status_print_task_id;



/* ID for semaphore that controls sensor reads */
SEM_ID gate_control_sem_id;

/* ID for watchdog timer to reschedule sensor reads task */
WDOG_ID gate_control_timer_ID;

/* ID of periodic task to read sensors */
int gate_control_task_id;

/* ID of periodic task to print state */
int gate_control_task_id;



/* Flag to read when execution has to be stopped */
int stopExecutionFlag = 0; 

/* Flags to open/close gates */
char gatesFlag[2] = {0 ,0}; 

void openGateFlagSet(int gate)
{
	gatesFlag[gate] = 0;
}

void closeGateFlagSet(int gate)
{
	gatesFlag[gate] = 1;
}

void closeGatesFlagTimer(int gate)
{
	WDOG_ID close_gates_flag_timer_ID;
	close_gates_flag_timer_ID = wdCreate();
	wdStart(close_gates_flag_timer_ID, 3 * sysClkRateGet(), (FUNCPTR)closeGateFlagSet, gate);
}

void openGatesFlagTimer(int gate)
{
	/* Create */
	WDOG_ID open_gates_flag_timer_ID;
	open_gates_flag_timer_ID = wdCreate();
	wdStart(open_gates_flag_timer_ID, 1 * sysClkRateGet(), (FUNCPTR)openGateFlagSet, gate);
}

/* Periodic task to control gates when flags are raised */
void controlGates(void)
{
	while(1)
		{	
			/* Wait until next reading */
			semTake(gate_control_sem_id, WAIT_FOREVER);
			
			printf("Controlling gates...");
			
			/* Read gate flag and set gates */
			if(gatesFlag[0] == 1 && gatesFlag[1] == 1)
			{
				/* Close both gates */
				setGates(3);
				
				/*Set timer to reopen gates*/
				openGatesFlagTimer(0);
				openGatesFlagTimer(1);
				
			}
			else if (gatesFlag[0] == 1 && gatesFlag[1] == 0)
			{
				/* Close gate 0, open gate 1 */
				setGates(2);
				
				/*Set timer to reopen gate*/
				openGatesFlagTimer(0);
			}
			else if(gatesFlag[0] == 0 && gatesFlag[1] == 1)
			{
				/* Open gate 0, close gate 1 */
				setGates(1);
				
				/*Set timer to reopen gate*/
				openGatesFlagTimer(1);
			}
			else 
			{
				/* Open both gates */
				setGates(0);
			}
		}
}

void sensorReadTimerCallback(void) /* No printf statements due to interrupt */
{
	/* After set time, give semaphore to trigger sensor reading */
	semGive(sensor_read_sem_id);
	
	if(stopExecutionFlag == 0)
	{
		wdStart(sensor_read_timer_ID, 1 * sysClkRateGet(), (FUNCPTR)sensorReadTimerCallback, 0);
	}
}

void gateControlTimerCallback()
{
	/* After time has expired, give semaphore to start gate control */
	semGive(gate_control_sem_id);
	
	/* If stop command isn't issued, restart task */
	if(stopExecutionFlag == 0)
	{
		wdStart(sensor_read_timer_ID, 2 * sysClkRateGet(), (FUNCPTR)gateControlTimerCallback, 0);
	}
}

/* In case there's a new state of the sensors, raise needed flags for the belt specified */
void processSensorReading(char newReading,  /* New value read from sensors */
						  char oldReading,	/* Previous value read from sensors  */
						  char belt) 		/* Belt - 0 for left, 1 for right */
{	
	printf("\nProcessing readings of sensor %c", &belt);
	
	if(newReading == 1)
	{
		/* Block detected in front of first size sensor */
		blocksDetected++;
	}
	else if(newReading == 0 && oldReading == 1)
	{
		/* Small block detected */
		smallBlocksDetected++;
		
		/* Create timer to set flag to 1 after 3 seconds */
		closeGatesFlagTimer(belt);
	}
}

void readSingleSensor(char sensor, char oldReading)
{
	char newReading;
	
	/* Reset sensor to be able to read from it */
	resetSizeSensors(sensor);
	
	/* Read the specified sensor */
	newReading = readSizeSensors(sensor);
	
	if(newReading != oldReading)
	{
		printf("\nNew state of left sensors.");
		processSensorReading(newReading, oldReading, sensor);
	}
}

/* Read sensors task scheduled to run every 5 seconds */
void readSensors(void)
{
	char leftSensorOldReading = 0;
	char rightSensorOldReading = 0;
	
	while(1)
	{	
		/* Wait until next reading */
		semTake(sensor_read_sem_id, WAIT_FOREVER);
		
		printf("Reading sensors...");
		
		/* Read and process left sensor reading */
		readSingleSensor(0, leftSensorOldReading);
		
		/* Read and process right sensor reading */
		readSingleSensor(1, rightSensorOldReading);
	}
}

void statusPrint(void)
{
	while(stopExecutionFlag == 0)
	{
		bigBlocksDetected = blocksDetected - smallBlocksDetected;
		
		printf("\nTotal blocks detected: %d", blocksDetected);
		printf("\nSmall blocks detected: %d", smallBlocksDetected);
		printf("\nBig blocks detected: %d", bigBlocksDetected);	
		
		taskDelay(10 * sysClkRateGet());
	}
	
	printf("Stop execution flag changed.");
}

void setupSensorReading(void)
{
	printf("\nSetting up sensor reading scheduling: creating semaphore, WD timer and task.");
	
	/* Create empty binary semaphore for sensor read task scheduler */
	sensor_read_sem_id = semBCreate(SEM_Q_FIFO, SEM_EMPTY);
	
	/* Create watchdog timer for sensor read task scheduler */
	sensor_read_timer_ID = wdCreate();

	/* Start timer for sensor read scheduling - current timing 1 sec*/
	wdStart(sensor_read_timer_ID, 1 * sysClkRateGet(), (FUNCPTR)sensorReadTimerCallback, 0);

	/* Create sensor reading task to wait until scheduled time is up*/
	sensor_read_task_id = taskSpawn("SensorRead", 100, 0, 20000, (FUNCPTR)readSensors, 0,0,0,0,0,0,0,0,0,0);
}

void setupGateControl(void)
{
	printf("\nSetting up gate control: creating semaphore, WD timer and task.");
	
	/* Create empty binary semaphore for gate control scheduling*/
	gate_control_sem_id = semBCreate(SEM_Q_FIFO, SEM_EMPTY);

	/* Create watchdog timer for gate control scheduling*/
	gate_control_timer_ID = wdCreate();
	
	/*Start timer for gate control*/
	wdStart(gate_control_timer_ID, 2 * sysClkRateGet(),  (FUNCPTR)gateControlTimerCallback, 0);
	
	gate_control_task_id = taskSpawn("GateControl", 99, 0, 20000, (FUNCPTR)controlGates, 0,0,0,0,0,0,0,0,0,0);
}

void setupStatusOutput()
{
	printf("\nCreating a task to setup status output");
	status_print_task_id = taskSpawn("Status Print", 98, 0, 20000, (FUNCPTR)statusPrint, 0,0,0,0,0,0,0,0,0,0);
}

void endExecution(void)
{
	/* Raise stop execution flag */
	stopExecutionFlag = 1; 
	
	/* Delete task that outputs status */
	taskDelete(status_print_task_id); 
		
	/* Wait for tasks to register change */
	taskDelay(10 * sysClkRateGet());
		
	/* Stop the motor */
	stopMotor();
}

int main(void) 
{		
	printf("\nNew run.\nStarting motor");
	startMotor();
	setGates(3);
	
	/* Create watchdog timer, semaphore and task for sensor reading */
	setupSensorReading();
	
	/* Create a task for status output */
	setupStatusOutput();
	
	/* Create a semaphore for gate control scheduling */
	/*setupGateControl();*/
	
	/* Run for 60 seconds */
	taskDelay(60 * sysClkRateGet());
	
	/* End execution after a minute */
	endExecution();
	
	return 0;
}
